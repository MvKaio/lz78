#ifndef ENCODER_CPP
#define ENCODER_CPP

#include "trie.cpp"
#include <string>
#include <vector>
#include <utility>

using std::string, std::vector, std::pair;

// Performs the lz78 compression method,
// returning the result as a list of tokens.
vector<pair<int, char>> encode(string& s) {
	Trie trie;
	int current_node = 0; // starts at the root

	s += '\0'; // guarantees the last token is saved

	vector<pair<int, char>> tokens;

	for (int i = 0; i < s.size(); i++) {
		int next_node = trie.next_node(current_node, s[i]);
		if (next_node == -1) { // found new token
			trie.insert(current_node, s[i]);
			tokens.emplace_back(current_node, s[i]);
			current_node = 0;
		} else {
			current_node = next_node;
		}
	}

	return tokens;
}

// Writes the result of the compression into the `out` stream
// Note that the output generated is not plain text, but the raw bytes
// The list of tokens should be generated by the `encode` method
bool write_to_a_file(vector<pair<int, char>>& tokens, std::ostream& out) {
	for (auto& [node, ch] : tokens) {
		out.write((const char*)&node, sizeof(int));
		out << ch;
	}
	return not out.fail();
}

// Decodes a compressed file encoded with this implementation of lz78,
// returning the resulting string
string decode(std::istream& input) {
	Trie trie;
	string answer;

	int node;
	char new_char;
	for (int index = 1; input; index++) {
		input.read((char*)&node, sizeof(int));
		input.get(new_char);
		if (!input) break;
		trie.insert(node, new_char);
		answer += trie.get_string(index);
		if (new_char == '\0')
			answer.pop_back();
	}

	return answer;
}

#endif
